<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‹“æ‰‘å›¾å¯è§†åŒ–</title>
    <script src="./echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f1621 0%, #1c2331 100%);
            color: #e9ecef;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        header {
            text-align: center;
            padding: 20px 0;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .subtitle {
            color: #adb5bd;
            font-size: 1.1rem;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        .chart-container {
            background: #1e2839;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            height: 700px;
            position: relative;
        }
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .card {
            background: #1e2839;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .card h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #4facfe;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        .stat-item {
            text-align: center;
            padding: 15px;
            background: #2a3447;
            border-radius: 8px;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #00f2fe;
            margin: 5px 0;
        }
        .stat-label {
            color: #adb5bd;
            font-size: 0.9rem;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        button {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4);
        }
        .node-info {
            line-height: 1.6;
        }
        .node-info div {
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }
        .node-info span:first-child {
            color: #adb5bd;
        }
        .node-info span:last-child {
            font-weight: 500;
        }
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        footer {
            text-align: center;
            margin-top: 20px;
            color: #6c757d;
            font-size: 0.9rem;
        }
        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        .search-box {
            background: #2a3447;
            border: 1px solid #3e4a61;
            border-radius: 8px;
            padding: 8px 15px;
            color: white;
            width: 200px;
        }
        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4facfe;
            font-size: 1.2rem;
            z-index: 10;
        }
        .zoom-controls {
            position: absolute;
            right: 30px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        .zoom-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #2a3447;
            color: white;
            border: 1px solid #3e4a61;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
        }
        .zoom-btn:hover {
            background: #3e4a61;
        }
        .filter-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .filter-btn {
            background: #2a3447;
            color: #adb5bd;
            border: 1px solid #3e4a61;
            padding: 6px 12px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .filter-btn.active {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }
        .drag-hint {
            position: absolute;
            bottom: 70px;
            right: 30px;
            background: rgba(46, 50, 65, 0.8);
            color: #adb5bd;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        @media (max-width: 992px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            .toolbar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>æ‹“æ‰‘å›¾å¯è§†åŒ–ç³»ç»Ÿ</h1>
            <p class="subtitle">åŸºäºSpring Boot + EChartsçš„åˆ†å¸ƒå¼ç³»ç»Ÿæ‹“æ‰‘å›¾</p>
        </header>

        <div class="toolbar">
            <div class="filter-controls">
                <button class="filter-btn active" data-type="all">å…¨éƒ¨èŠ‚ç‚¹</button>
                <button class="filter-btn" data-type="service">æœåŠ¡èŠ‚ç‚¹</button>
                <button class="filter-btn" data-type="database">æ•°æ®åº“èŠ‚ç‚¹</button>
                <button class="filter-btn" data-type="gateway">ç½‘å…³èŠ‚ç‚¹</button>
            </div>
            <div>
                <input type="text" class="search-box" placeholder="æœç´¢èŠ‚ç‚¹..." id="search-input">
            </div>
            <div>
                <button id="export-btn">å¯¼å‡ºå›¾ç‰‡</button>
                <button id="save-layout-btn" style="margin-left: 10px;">ä¿å­˜å¸ƒå±€</button>
            </div>
        </div>

        <div class="dashboard">
            <div class="chart-container">
                <div id="graph-chart" style="width: 100%; height: 100%;"></div>
                <div id="loading" class="loading">åŠ è½½ä¸­...</div>
                <div class="drag-hint">
                    <span>ğŸ’¡</span> æ‹–æ‹½èŠ‚ç‚¹å¯è°ƒæ•´ä½ç½®
                </div>
                <div class="zoom-controls">
                    <div class="zoom-btn" id="zoom-in">+</div>
                    <div class="zoom-btn" id="zoom-reset">â†º</div>
                    <div class="zoom-btn" id="zoom-out">-</div>
                </div>
            </div>

            <div class="sidebar">
                <div class="card">
                    <h2>ğŸ“Š ç³»ç»Ÿæ¦‚è§ˆ</h2>
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-value" id="vertex-count">0</div>
                            <div class="stat-label">èŠ‚ç‚¹æ•°é‡</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="edge-count">0</div>
                            <div class="stat-label">è¿æ¥æ•°é‡</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>ğŸ” èŠ‚ç‚¹è¯¦æƒ…</h2>
                    <div class="node-info" id="node-details">
                        <div><span>èŠ‚ç‚¹åç§°:</span> <span id="node-name">-</span></div>
                        <div><span>è¿æ¥æ•°:</span> <span id="node-degree">-</span></div>
                        <div><span>çŠ¶æ€:</span> <span id="node-status">-</span></div>
                        <div><span>ç±»å‹:</span> <span id="node-type">-</span></div>
                        <div><span>èšç±»:</span> <span id="node-cluster">-</span></div>
                    </div>
                </div>

                <div class="card">
                    <h2>ğŸ›ï¸ å›¾æ“ä½œ</h2>
                    <div class="controls">
                        <button id="layout-btn">åˆ‡æ¢å¸ƒå±€</button>
                        <button id="cluster-btn">åˆ‡æ¢èšç±»</button>
                        <button id="reset-btn">é‡ç½®è§†å›¾</button>
                        <button id="refresh-btn">åˆ·æ–°æ•°æ®</button>
                        <button id="restore-layout-btn">æ¢å¤å¸ƒå±€</button>
                    </div>
                </div>

                <div class="card">
                    <h2>ğŸ“‘ å›¾ä¾‹è¯´æ˜</h2>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #4facfe;"></div>
                            <span>æœåŠ¡èŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #00f2fe;"></div>
                            <span>æ•°æ®åº“èŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #ff6b6b;"></div>
                            <span>ç½‘å…³èŠ‚ç‚¹</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Â© 2023 æ‹“æ‰‘å›¾å¯è§†åŒ–ç³»ç»Ÿ | åŸºäºEChartså®ç°</p>
        </footer>
    </div>

    <script>
        // åˆå§‹åŒ–EChartså®ä¾‹
        const chartDom = document.getElementById('graph-chart');
        const myChart = echarts.init(chartDom);
        const loadingElement = document.getElementById('loading');
        
        // å­˜å‚¨åŸå§‹æ•°æ®å’Œå¤„ç†åçš„æ•°æ®
        let originalGraphData = null;
        let processedNodes = [];
        let processedLinks = [];
        let currentLayout = 'force';
        let enableClustering = true;
        let currentZoom = 1;
        let isDragging = false;
        let savedLayouts = {};
        
        // å›¾è¡¨é…ç½®é€‰é¡¹
        let option = {
            title: {
                text: 'ç³»ç»Ÿæ‹“æ‰‘å›¾',
                textStyle: {
                    color: '#e9ecef'
                },
                left: 'center'
            },
            tooltip: {
                formatter: function(params) {
                    if (params.dataType === 'node') {
                        return `èŠ‚ç‚¹: ${params.name}<br/>è¿æ¥æ•°: ${params.value}<br/>èšç±»: ${params.data.cluster || 'æ— '}`;
                    } else {
                        return `è¿æ¥: ${params.data.source} â†’ ${params.data.target}`;
                    }
                }
            },
            legend: {
                show: false
            },
            animation: true,
            animationDuration: 1500,
            animationEasing: 'cubicOut',
            series: [{
                type: 'graph',
                layout: 'force',
                force: {
                    repulsion: 300,
                    gravity: 0.05,
                    edgeLength: [50, 200],
                    layoutAnimation: true,
                    friction: 0.8
                },
                data: [],
                links: [],
                categories: [{
                    name: 'æœåŠ¡èŠ‚ç‚¹'
                }, {
                    name: 'æ•°æ®åº“èŠ‚ç‚¹'
                }, {
                    name: 'ç½‘å…³èŠ‚ç‚¹'
                }],
                roam: true,
                zoom: 1,
                focusNodeAdjacency: true,
                label: {
                    show: true,
                    position: 'right',
                    formatter: '{b}',
                    color: '#e9ecef',
                    fontSize: 12
                },
                lineStyle: {
                    color: 'source',
                    curveness: 0.2,
                    width: 1.5,
                    opacity: 0.6
                },
                emphasis: {
                    focus: 'adjacency',
                    lineStyle: {
                        width: 3,
                        opacity: 1
                    }
                },
                // å¯ç”¨èŠ‚ç‚¹æ‹–æ‹½
                draggable: true
            }]
        };

        // è®¾ç½®åˆå§‹é€‰é¡¹
        myChart.setOption(option);

        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        function showLoading() {
            loadingElement.style.display = 'block';
            myChart.showLoading();
        }

        // éšè—åŠ è½½çŠ¶æ€
        function hideLoading() {
            loadingElement.style.display = 'none';
            myChart.hideLoading();
        }

        // ä»åç«¯APIè·å–æ•°æ®
        async function fetchGraphData() {
            showLoading();
            try {
                // ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼Œå®é™…åº”ç”¨ä¸­æ›¿æ¢ä¸ºçœŸå®APIè°ƒç”¨
                 const response = await fetch('http://localhost:8080/machine-gateway-server/machine-temp-test/temp/graph/test');
                 const result = await response.json();
                
               

                if (result.code === "SUCCESS") {
                    originalGraphData = result.data;
                    processGraphData(originalGraphData);
                } else {
                    console.error('APIè¿”å›é”™è¯¯:', result.message);
                    alert('è·å–æ•°æ®å¤±è´¥: ' + result.message);
                }
            } catch (error) {
                console.error('è·å–æ•°æ®å¤±è´¥:', error);
                alert('è·å–æ•°æ®å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–APIåœ°å€æ˜¯å¦æ­£ç¡®');
            } finally {
                hideLoading();
            }
        }

        // ä½¿ç”¨ç¤¾åŒºæ£€æµ‹ç®—æ³•è¿›è¡ŒèŠ‚ç‚¹èšç±»
        function detectCommunities(nodes, links) {
            // ç®€åŒ–çš„Louvainç¤¾åŒºæ£€æµ‹ç®—æ³•
            const communities = {};
            const nodeCommunity = {};
            
            // åˆå§‹åŒ–æ¯ä¸ªèŠ‚ç‚¹ä¸ºè‡ªå·±çš„ç¤¾åŒº
            nodes.forEach((node, i) => {
                communities[i] = new Set([node.name]);
                nodeCommunity[node.name] = i;
            });
            
            // è¿­ä»£ä¼˜åŒ–ç¤¾åŒºåˆ†é…
            let changed = true;
            let iterations = 0;
            
            while (changed && iterations < 10) {
                changed = false;
                iterations++;
                
                nodes.forEach(node => {
                    const currentCommunity = nodeCommunity[node.name];
                    const neighborCommunities = new Map();
                    
                    // æ‰¾åˆ°æ‰€æœ‰é‚»å±…èŠ‚ç‚¹æ‰€åœ¨çš„ç¤¾åŒº
                    links.forEach(link => {
                        if (link.source === node.name) {
                            const comm = nodeCommunity[link.target];
                            neighborCommunities.set(comm, (neighborCommunities.get(comm) || 0) + 1);
                        } else if (link.target === node.name) {
                            const comm = nodeCommunity[link.source];
                            neighborCommunities.set(comm, (neighborCommunities.get(comm) || 0) + 1);
                        }
                    });
                    
                    // æ‰¾åˆ°è¿æ¥æœ€ç´§å¯†çš„ç¤¾åŒº
                    let bestCommunity = currentCommunity;
                    let maxConnections = -1;
                    
                    neighborCommunities.forEach((count, comm) => {
                        if (count > maxConnections) {
                            maxConnections = count;
                            bestCommunity = comm;
                        }
                    });
                    
                    // å¦‚æœæ‰¾åˆ°æ›´å¥½çš„ç¤¾åŒºï¼Œç§»åŠ¨èŠ‚ç‚¹
                    if (bestCommunity !== currentCommunity) {
                        // ä»åŸç¤¾åŒºç§»é™¤
                        communities[currentCommunity].delete(node.name);
                        
                        // æ·»åŠ åˆ°æ–°ç¤¾åŒº
                        communities[bestCommunity].add(node.name);
                        nodeCommunity[node.name] = bestCommunity;
                        
                        changed = true;
                    }
                });
            }
            
            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹åˆ†é…ç¤¾åŒºID
            const communityMap = {};
            let communityId = 1;
            
            Object.values(communities).forEach(community => {
                if (community.size > 0) {
                    community.forEach(nodeName => {
                        communityMap[nodeName] = communityId;
                    });
                    communityId++;
                }
            });
            
            return communityMap;
        }

        // å¤„ç†å›¾æ•°æ®
        function processGraphData(graphData) {
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            document.getElementById('vertex-count').textContent = graphData.vertexCount;
            document.getElementById('edge-count').textContent = graphData.edgeCount;
            
            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„è¿æ¥æ•°
            const nodeDegrees = {};
            graphData.vertices.forEach(vertex => {
                nodeDegrees[vertex] = 0;
            });
            
            // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„çœŸå®è¿æ¥æ•°ï¼ˆä¸è€ƒè™‘åŒå‘é‡å¤ï¼‰
            const uniqueConnections = new Set();
            
            graphData.edges.forEach(edge => {
                const key1 = `${edge.source}-${edge.destination}`;
                const key2 = `${edge.destination}-${edge.source}`;
                
                // åªè®¡ç®—ä¸€æ¬¡è¿æ¥ï¼Œé¿å…åŒå‘è¿æ¥é‡å¤è®¡æ•°
                if (!uniqueConnections.has(key1) && !uniqueConnections.has(key2)) {
                    nodeDegrees[edge.source]++;
                    nodeDegrees[edge.destination]++;
                    uniqueConnections.add(key1);
                }
            });
            
            // å‡†å¤‡èŠ‚ç‚¹æ•°æ®
            processedNodes = graphData.vertices.map(vertex => {
                // æ ¹æ®èŠ‚ç‚¹åç§°åˆ†é…ç±»å‹ï¼ˆåœ¨å®é™…åº”ç”¨ä¸­åº”æ ¹æ®ä¸šåŠ¡é€»è¾‘åˆ†é…ï¼‰
                let category = 0; // é»˜è®¤æœåŠ¡èŠ‚ç‚¹
                
                if (vertex >= 'U' && vertex <= 'Z') {
                    category = 1; // æ•°æ®åº“èŠ‚ç‚¹
                } else if (vertex >= 'A' && vertex <= 'F') {
                    category = 2; // ç½‘å…³èŠ‚ç‚¹
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„ä½ç½®ä¿¡æ¯
                let fixed = false;
                let x, y;
                
                if (savedLayouts[vertex]) {
                    fixed = true;
                    x = savedLayouts[vertex].x;
                    y = savedLayouts[vertex].y;
                }
                
                return {
                    name: vertex,
                    value: nodeDegrees[vertex], // å®é™…è¿æ¥æ•°
                    symbolSize: 20 + Math.min(nodeDegrees[vertex] * 3, 40), // èŠ‚ç‚¹å¤§å°åŸºäºè¿æ¥æ•°
                    category: category,
                    itemStyle: {
                        color: category === 0 ? '#4facfe' : category === 1 ? '#00f2fe' : '#ff6b6b'
                    },
                    fixed: fixed,
                    x: x,
                    y: y,
                    draggable: true
                };
            });
            
            // å‡†å¤‡è¾¹æ•°æ® - å»é™¤é‡å¤çš„åŒå‘è¿æ¥
            processedLinks = [];
            const addedEdges = new Set();
            
            graphData.edges.forEach(edge => {
                const key1 = `${edge.source}-${edge.destination}`;
                const key2 = `${edge.destination}-${edge.source}`;
                
                // åªæ·»åŠ ä¸€æ¬¡è¿æ¥ï¼Œé¿å…åŒå‘è¿æ¥é‡å¤æ˜¾ç¤º
                if (!addedEdges.has(key1) && !addedEdges.has(key2)) {
                    processedLinks.push({
                        source: edge.source,
                        target: edge.destination,
                        lineStyle: {
                            color: '#7e8eab',
                            opacity: 0.6
                        }
                    });
                    addedEdges.add(key1);
                }
            });
            
            // åº”ç”¨ç¤¾åŒºæ£€æµ‹ç®—æ³•
            if (enableClustering) {
                applyClustering(processedNodes, processedLinks);
            }
            
            // æ›´æ–°å›¾è¡¨
            updateChart();
        }

        // åº”ç”¨èšç±»ç®—æ³•
        function applyClustering(nodes, links) {
            const communityMap = detectCommunities(nodes, links);
            
            // ä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ èšç±»ä¿¡æ¯
            nodes.forEach(node => {
                node.cluster = communityMap[node.name] || 0;
                
                // æ ¹æ®èšç±»åˆ†é…ä¸åŒçš„ç¬¦å·å’Œé¢œè‰²
                if (node.cluster > 0) {
                    // ä¿æŒåŸæœ‰ç±»åˆ«é¢œè‰²ï¼Œä½†æ·»åŠ èšç±»æ ‡è¯†
                    node.symbol = 'circle';
                    node.itemStyle = {
                        ...node.itemStyle,
                        borderColor: '#fff',
                        borderWidth: 2
                    };
                }
            });
            
            // ä¸ºåŒä¸€èšç±»çš„è¾¹æ·»åŠ ç›¸åŒé¢œè‰²
            links.forEach(link => {
                const sourceCluster = nodes.find(n => n.name === link.source)?.cluster || 0;
                const targetCluster = nodes.find(n => n.name === link.target)?.cluster || 0;
                
                if (sourceCluster === targetCluster && sourceCluster > 0) {
                    // åŒä¸€èšç±»çš„è¾¹ä½¿ç”¨ç›¸åŒé¢œè‰²
                    const hue = (sourceCluster * 137.5) % 360; // ä½¿ç”¨é»„é‡‘è§’åˆ†å¸ƒé¢œè‰²
                    link.lineStyle = {
                        color: `hsla(${hue}, 70%, 60%, 0.7)`,
                        width: 1.5
                    };
                } else {
                    // è·¨èšç±»çš„è¾¹ä½¿ç”¨ç°è‰²
                    link.lineStyle = {
                        color: 'rgba(200, 200, 200, 0.3)',
                        width: 1
                    };
                }
            });
        }

        // æ›´æ–°å›¾è¡¨æ˜¾ç¤º
        function updateChart() {
            myChart.setOption({
                series: [{
                    data: processedNodes,
                    links: processedLinks,
                    layout: currentLayout,
                    force: {
                        repulsion: currentLayout === 'force' ? 300 : 50,
                        gravity: currentLayout === 'force' ? 0.05 : 0.2
                    }
                }]
            });
        }

        // ä¿å­˜å½“å‰å¸ƒå±€åˆ°æœ¬åœ°å­˜å‚¨
        function saveLayout() {
            const currentOption = myChart.getOption();
            const nodes = currentOption.series[0].data;
            
            const layout = {};
            nodes.forEach(node => {
                if (node.x !== undefined && node.y !== undefined) {
                    layout[node.name] = {
                        x: node.x,
                        y: node.y
                    };
                }
            });
            
            savedLayouts = layout;
            localStorage.setItem('topologyLayout', JSON.stringify(layout));
            alert('å¸ƒå±€å·²ä¿å­˜ï¼åˆ·æ–°é¡µé¢åå¯ä½¿ç”¨"æ¢å¤å¸ƒå±€"åŠŸèƒ½æ¢å¤ã€‚');
        }

        // ä»æœ¬åœ°å­˜å‚¨æ¢å¤å¸ƒå±€
        function restoreLayout() {
            const savedLayout = localStorage.getItem('topologyLayout');
            if (savedLayout) {
                try {
                    savedLayouts = JSON.parse(savedLayout);
                    if (originalGraphData) {
                        processGraphData(originalGraphData);
                    }
                    alert('å¸ƒå±€å·²æ¢å¤ï¼');
                } catch (e) {
                    console.error('æ¢å¤å¸ƒå±€å¤±è´¥:', e);
                    alert('æ¢å¤å¸ƒå±€å¤±è´¥ï¼Œæ•°æ®æ ¼å¼é”™è¯¯');
                }
            } else {
                alert('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„å¸ƒå±€');
            }
        }

        // åˆå§‹åŒ–åŠ è½½æ•°æ®
        fetchGraphData();

        // æ·»åŠ äº¤äº’äº‹ä»¶
        myChart.on('click', function(params) {
            if (params.dataType === 'node') {
                // æ›´æ–°èŠ‚ç‚¹è¯¦æƒ…ä¿¡æ¯
                document.getElementById('node-name').textContent = params.name;
                document.getElementById('node-degree').textContent = params.value;
                document.getElementById('node-status').textContent = 'æ­£å¸¸';
                document.getElementById('node-type').textContent = 
                    params.data.category === 0 ? 'æœåŠ¡èŠ‚ç‚¹' : 
                    params.data.category === 1 ? 'æ•°æ®åº“èŠ‚ç‚¹' : 'ç½‘å…³èŠ‚ç‚¹';
                document.getElementById('node-cluster').textContent = params.data.cluster || 'æ— ';
                
                // é«˜äº®ç›¸å…³èŠ‚ç‚¹å’Œè¾¹
                myChart.dispatchAction({
                    type: 'focusNodeAdjacency',
                    seriesIndex: 0,
                    dataIndex: params.dataIndex
                });
            }
        });

        // æ·»åŠ èŠ‚ç‚¹æ‹–æ‹½äº‹ä»¶
        myChart.on('drag', function(params) {
            isDragging = true;
        });

        myChart.on('dragend', function(params) {
            isDragging = false;
            // æ›´æ–°èŠ‚ç‚¹ä½ç½®ä¿¡æ¯
            if (params.dataType === 'node') {
                const nodeIndex = params.dataIndex;
                processedNodes[nodeIndex].x = params.event.offsetX;
                processedNodes[nodeIndex].y = params.event.offsetY;
                processedNodes[nodeIndex].fixed = true;
            }
        });

        // æ·»åŠ æŒ‰é’®äº‹ä»¶
        document.getElementById('layout-btn').addEventListener('click', function() {
            // åˆ‡æ¢å¸ƒå±€é€»è¾‘
            currentLayout = currentLayout === 'force' ? 'circular' : 'force';
            updateChart();
        });

        document.getElementById('cluster-btn').addEventListener('click', function() {
            // åˆ‡æ¢èšç±»æ˜¾ç¤º
            enableClustering = !enableClustering;
            if (originalGraphData) {
                processGraphData(originalGraphData);
            }
        });

        document.getElementById('reset-btn').addEventListener('click', function() {
            myChart.dispatchAction({
                type: 'graphRoam',
                zoom: 1,
                originX: 0,
                originY: 0
            });
            currentZoom = 1;
        });

        document.getElementById('refresh-btn').addEventListener('click', function() {
            fetchGraphData();
        });

        document.getElementById('export-btn').addEventListener('click', function() {
            const imgData = myChart.getDataURL({
                type: 'png',
                pixelRatio: 2,
                backgroundColor: '#1e2839'
            });
            const link = document.createElement('a');
            link.href = imgData;
            link.download = 'æ‹“æ‰‘å›¾.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // ä¿å­˜å¸ƒå±€æŒ‰é’®
        document.getElementById('save-layout-btn').addEventListener('click', saveLayout);

        // æ¢å¤å¸ƒå±€æŒ‰é’®
        document.getElementById('restore-layout-btn').addEventListener('click', restoreLayout);

        // ç¼©æ”¾æ§åˆ¶
        document.getElementById('zoom-in').addEventListener('click', function() {
            currentZoom *= 1.2;
            myChart.dispatchAction({
                type: 'graphRoam',
                zoom: currentZoom,
                originX: 0,
                originY: 0
            });
        });

        document.getElementById('zoom-out').addEventListener('click', function() {
            currentZoom /= 1.2;
            myChart.dispatchAction({
                type: 'graphRoam',
                zoom: currentZoom,
                originX: 0,
                originY: 0
            });
        });

        document.getElementById('zoom-reset').addEventListener('click', function() {
            currentZoom = 1;
            myChart.dispatchAction({
                type: 'graphRoam',
                zoom: currentZoom,
                originX: 0,
                originY: 0
            });
        });

        // èŠ‚ç‚¹è¿‡æ»¤
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                const filterType = this.dataset.type;
                let filteredNodes = processedNodes;
                
                if (filterType !== 'all') {
                    const categoryMap = {
                        'service': 0,
                        'database': 1,
                        'gateway': 2
                    };
                    
                    filteredNodes = processedNodes.filter(node => 
                        node.category === categoryMap[filterType]
                    );
                }
                
                myChart.setOption({
                    series: [{
                        data: filteredNodes
                    }]
                });
            });
        });

        // æœç´¢åŠŸèƒ½
        document.getElementById('search-input').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            
            if (!searchTerm) {
                myChart.setOption({
                    series: [{
                        data: processedNodes
                    }]
                });
                return;
            }
            
            const filteredNodes = processedNodes.filter(node => 
                node.name.toLowerCase().includes(searchTerm)
            );
            
            myChart.setOption({
                series: [{
                    data: filteredNodes
                }]
            });
        });

        // å“åº”çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', function() {
            myChart.resize();
        });

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„å¸ƒå±€
        window.addEventListener('load', function() {
            const savedLayout = localStorage.getItem('topologyLayout');
            if (savedLayout) {
                try {
                    savedLayouts = JSON.parse(savedLayout);
                } catch (e) {
                    console.error('åŠ è½½ä¿å­˜çš„å¸ƒå±€å¤±è´¥:', e);
                }
            }
        });
    </script>
</body>
</html>